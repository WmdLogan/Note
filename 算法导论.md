[TOC]

# 算法导论

## 第四章 分治策略

### 4.1 最大子数组问题（Maximum subarray problem)

思路：任何子数组必为以下三种情况之一：

1. 完全位于子数组A[low..mid]中
2. 完全位于子数组A[mid+1..high]中
3. 跨越了中点，因此low <= i <= mid <j <=high*

```c++
#include "iostream"

using namespace std;
//求出最大的跨越中点的数组
int* MAX;
int* find_max_mid(int add[], int L, int M, int R){
    int *max;
    max = (int *) malloc(3 * sizeof(int));
    int left_sum = -65535;
    int right_sum = -65535;
    int sum = 0;
    int  j;
    for (j = M; j >= L; j--) {
        sum += add[j];
        if (sum > left_sum) {
            left_sum = sum;
            max[0] = j;
        }
    }
    sum = 0;
    for (j = M + 1; j <= R; j++) {
        sum += add[j];
        if (sum > right_sum) {
            right_sum = sum;
            max[1] = j;
        }
    }
    max[2] = left_sum + right_sum;
    return max;
}
//递归求左子数组、右子数组、跨越中点的数组，并比较大小
int* find_max(int A[], int low, int high){
    int *result;
    int mid;
    int *result_left,*result_right,*result_cross;
    result = (int *)malloc(sizeof(int)*3);
    result_left = (int *)malloc(sizeof(int)*3);//最大左子数组的指针{low, high, sum_left}
    result_right = (int *)malloc(sizeof(int)*3);//最大右子数组的指针{low, high, sum_right}
    result_cross = (int *)malloc(sizeof(int)*3);//最大跨中点子数组的指针{low, high, sum_cross}
    if(high == low)
    {
        result[0] = low;
        result[1] = high;
        result[2] = A[low];
        return result;
    }
    else
    {
        mid = (int)((low+high)/2);
        result_left = find_max(A,low,mid);
        result_right = find_max(A,mid+1,high);
        result_cross = find_max_mid(A,low,mid,high);
        if(result_left[2] >= result_right[2]  && result_left[2] >= result_cross[2])
            return result_left;
        else if(result_right[2] >= result_left[2] && result_right[2] >= result_cross[2])
            return result_right;
        else
            return result_cross;
    }
}

int main(){
    int a[] = {18, 20, -7, 12, 13, -3, -25, 20, -3, -16, -23,-5, -22, 15, -4 ,7};
    int *max;
    max = find_max(a, 0, 15);
    cout << max[0] << " " << max[1] << " " << max[2];
}
```

### 4.2 矩阵乘法的Strassen算法

劝退

## 第六章 堆排序

### 6.1 堆排序算法

思路：

heapify：给定一个节点，递归调用该函数，从该结点开始建立大根堆

build_heap：从最后一个父亲结点开始调用heapify，建立大根堆

heap_sort：将n个元素的大根堆的顶部元素跟最后一个元素交换，heapify顶部的元素

```c++
void swap(int add[], int i, int j){
    int a = add[i];
    add[i] = add[j];
    add[j] = a;
}

void heapify(int add[], int n, int i) {
    if (i >= n) {
        return;
    }
    int left_child = 2 * i + 1;
    int right_child = 2 * i + 2;
    int max = i;
    if (left_child < n && add[left_child] > add[max]) {
        max = left_child;
    }
    if (right_child < n && add[right_child] > add[max]) {
        max = right_child;
    }
    if (max != i) {
        swap(add, max, i);
        heapify(add, n, max);
    }
}
//建立大根堆
void build_heap(int add[], int n){
    int last_parent = ( n - 2 ) / 2;
    int i;
    for (i = last_parent; i >= 0; i--) {
        heapify(add, n, i);
    }
}

//排序
void heap_sort(int add[], int n){
    build_heap(add, n);
    int i;
    for (i = n - 1; i >= 0; i--) {
        swap(add, i, 0);
        heapify(add, i, 0);
    }
}

```

### 6.2 优先队列

**优先队列**是一种用来维护由一组元素构成的集合S的**数据结构**，其中每一个元素都有一个相关的值，成为**关键字**。一个**最大优先队列**支持以下操作：

- INSERT(S, x)：把元素x插入集合S中。
- MAXIMUM(S)：返回S中具有最大关键字的元素。
- EXTRACT-MAX(S)：去掉并返回S中的具有最大关键字的元素。
- INCREASE-KEY(S, x, k)：将元素x的关键字增加到k，这里假设k的值不小于x的原关键字值。

**最大优先队列的应用：**共享计算机系统的作业调度。最大优先队列记录将要执行的各个作业以及它们之间的相对优先级。当一个作业完成或者中断后，调用EXTRACT-MAX，从所有等待作业中选出具有最高优先级的作业来执行。任何时候可以调用INSERT把一个新作业加入到队列中来。

**最小优先队列的应用：**基于事件驱动的模拟器。

















