# 深入理解计算机系统

## 第一章 计算机系统漫游

- 

```
gcc -o hello hello.c
```

- **hello.c** -> 预处理器(cpp) -> **hello.i** -> 编译器(ccl) -> **hello.s** ->汇编器(as) -> **hello.o **->链接器(ld)  -> **hello**
  - hello.i：修改了的源程序（文本）
  - hello.s：汇编语言程序（文本）
  - hello.o：可重定位的目标程序 —— 打包机器语言指令（二进制）
  - hello：可执行目标程序（二进制），可以被加载到内存中，由系统执行

- **链接阶段**：将例如 printf.o 这些预编译好的单独文件合并到我们的程序中
- 计算机硬件组成
  - 总线被设计成传送定长的字节块，也就是**字（word）**，字长4个字节是32位系统，8个字节是64位系统
  - I/O设备通过**控制器或者适配器**与I/O总线相连，控制器和适配器的区别在于它们的组装方式。
- 程序的机器指令：磁盘 -> 主存 -> 处理器
- 上下文：操作系统保持跟踪进程运行所需的所有状态信息，包括PC、寄存器文件的当前值、主存的内容，操作系统通过上         下文切换来切换进程运行，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程
- 从一个进程到另一个进程的转换就是由操作系统**内核**管理的。**内核**是操作系统代码常驻主存的部分
- 进程的虚拟内存空间（P13）地址从小到大如下：
  - 程序代码和数据。对所有进程来说，代码从同一固定位置开始，紧接着是数据位置
  - 堆。malloc和free
  - 共享库。如C标准库和数学库
  - 内核虚拟内存。程序必须通过调用内核来读写这个区的内容或者调用内核代码定义的函数
- 线程级并发，指令级并行
- 操作系统内核时应用程序和硬件之间的媒介，提供了三个基本的抽象
  - 文件是对I/O设备的抽象
  - 虚拟内存是对主存和磁盘的抽象
  - 进程是对处理器、主存和I/O设备的抽象

## 第二章 信息的表示和处理

- 大多数计算机使用**字节**，作为最小的可寻址的内存单位。机器级程序将内存视为一个非常大的**字节数组**，成为**虚拟内存**
- 字长决定虚拟地址空间的最大大小，32位限制虚拟地址空间为4GB（刚超过4*10^9个字节）, 64位为4EB
- 排列表示一个对象的字节分小端法和大端法。通过网络传送二进制数据时必须转换成网络标准
- int float 指针等数据类型在不同机器上受字节顺序和字节大小影响，而ASCII码则不受影响。
- 几乎所有机器，C语言对有符号数使用算数右移/左移
- 强转保持位值不变，只是改变了解释这些位的方式。
  - 例如：-12345(1100111111000111)强转成无符号变为53191，原数+2^16
  - 最大无符号整数（11111111）强转成有符号变为-1
  - **有符号与无符号运算，隐式将有符号转换为无符号**容易造成程序错误

## 第三章 程序的机器级表示

- 机器级程序使用的内存地址是**虚拟地址**，提供的内存模型看上去是一个非常大的字节数组。**操作系统**负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址
- 机器代码只是简单的将内存看成一个很大的、按字节寻址的数组。
- 程序内存包含：
  - 程序的可执行机器代码
  - 操作系统需要的一些信息
  - 用来管理过程调用和返回的运行时栈
  - 用户分配的内存块
- linux中 object -d xxxx.o 反汇编机器代码
- 可以将字节唯一地解码成机器指令
- 一个x86-64的CPU包含一组16个存储64位值的**通用目的寄存器**，这些寄存器用来存储整数数据和指针
- 程序调用函数，将返回地址压入栈
- 数据传送（函数参数）通过寄存器实现，寄存器的使用取决于要传递的数据类型的大小。这样不同过程可以通过访问寄存器来访问参数。
- 如果一个函数有超过6个整形参数，超出6个的部分就要通过栈来传递
- 寄存器分为“被调用者保存寄存器”和“调用者保存寄存器”.当过程P调用过程Q时，不能改变前者，后者可以改变。
- struct 和 union 的区别
- 编译器会对struct进行数据对齐，确保字节数是4的倍数
- 将指针从一种类型强制转换成另一种类型，只改变它的类型，不改变它的值

## 第四章 处理器体系结构

- 处理一条指令：取指 -> 译码 -> 执行 -> 访存 -> 写回 -> 更新PC，处理器无限循环执行这些阶段
- 流水线执行

## 第五章 优化程序性能

- gcc编译器选项 -og、-o1、-o2、-o3调用gcc对程序优化
- 两个指针可能指向同一个内存位置的情况称为**内存别名使用**。如果编译器不能确定两个指针是否指向同一位置，就必须假设什么情况都有可能，这就限制了可能的优化策略

提升程序性能基本方法：

1. 消除循环的低效率
2. 减少过程调用（函数）
3. 消除不必要的内存引用：
   - *dest = *dest + data[i]  : 两次读一次写内存
   - acc = acc + data[i]: 只需要一次读

- 现代处理器指令级并行
  - 延迟界限：限制了处理器指令级并行的能力
  - 吞吐量界限：处理器功能单元的原始计算能力，是程序性能的终极限制
- 优化程序性能基本策略：
  - 高级设计
  - 基本编码原则
  - 低级优化
- 代码剖析程序（code profilter）：在程序执行时收集性能数据的分析工具（gcc -pg）
- unix系统提供了一个剖析程序GPROF，它产生两种形式的信息
  - 它确定程序中每个函数花费了多少CPU时间
  - 它计算每个函数被调用的次数，以执行调用的函数来分类

## 第六章 存储器层次结构

- 程序访问的数据存储在不同位置，需要的指令周期相差巨大
  - CPU寄存器中 - 0个周期
  - 高速缓存 - 4~75个周期
  - 主存 - 上百个周期
  - 磁盘 - 几千万个周期
- RAM
  - SRAM：速度快、贵。用来做高速缓存存储器，既可以在CPU芯片上，也可以在片下。具有**双稳态特性**
  - DRAM：慢、便宜。用来做主存、图形系统的帧缓冲区
- SRAM将每个**位**存储在一个双稳态存储器单元里；可以无限期的保持在两个不同的电压状态之一
- DRAM将每个**位**存储为对一个电容的充电；不稳定。被扰乱后无法恢复，因此需要周期性的进行刷新
- 数据流通过**一对**总线在处理器和DRAM主存之间来来回回
- 处理器和DRAM主存之间的数据传送是通过一系列成为**总线事务**的步骤完成的
- 总线事务分为读事务和写事务。
  - movq A, %rax     读事务
  - movq %rax, A     写事务

## 第七章 链接

- 链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行
- 链接使得**分离编译**成为可能
- 一组可重定位目标文件（.o） -> 静态链接器 -> 可执行目标文件
- 目标文件的三种形式
  - 可重定位目标文件
  - 可执行目标文件
  - 共享目标文件：一种特殊的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接
- 在Linux系统中，静态库以一种成为存档（archive）的特殊文件格式存放在磁盘中
- 存档文件是一组连接起来的可重定位目标文件的集合，有一个头部来描述每个成员目标文件的大小和位置
- 加载：将程序复制到内存并运行的过程
- 加载器将可执行目标文件中的代码和数据从磁盘复制到内存中
  - 接下来，加载器跳转到程序的入口点，也就是_start函数的地址
  - _start函数是系统文件ctrl.o中定义的，对所有C程序都一样
  - _start函数调用系统启动函数 _ _libc_start_main,该函数定义在libc.so中，它初始化执行环境，调用用户层的main函数
- 共享库（shared library）可以加载到任意的内存地址，并和一个在内存中的程序链接起来，这个过程为动态链接。共享库也称为共享目标（shared object）,在Linux系统中通常用.so后缀来表示

## 第八章 异常控制流

- 学习应用是如何与操作系统交互的。这些交互都围绕着ECF
- 异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。
- 异常是控制流中的突变，用来响应处理器状态中的某些变化
- 系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号。在操作系统启动时，操作系统分配和初始化一张称为**异常表**的跳转表
- 异常可以分成四类
  - 异步：中断(interrupt)
  - 同步：陷阱(trap)、故障(fault)、终止(abort)
- 异步异常是由处理器外部的I/O设备(网络适配器、磁盘控制器)中的事件产生的；同步异常是执行一条指令的直接产物
- 处理器通过设置控制寄存器的**模式位**来区分进程运行在内核模式中还是用户模式中
  - 运行在内核模式中的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置
  - 用户模式的进程不允许执行特权指令，比如停止处理器，改变模式位，或者发起一个I/O操作。也不允许直接引用地址空间中内核区内的代码和数据，必须通过系统调用接口间接地访问内核代码和数据
- 内核（操作系统常驻内存的部分）为每个进程维持一个上下文，上下文是内核重新启动一个被抢占的进程所需的状态
- main函数的三个参数
  - argc，它给出argv[]数组中非空指针的数量
  - argv，指向argv[]数组中的第一个条目
  - envp，指向envp[]数组中的第一个条目
- 信号：通知进程系统中发生了一个某种类型的事件。允许进程和内核中断其他进程
- 当一个进程终止时，内核并不是立即把它从操作系统中清除，而是让进程保持在一种已终止的状态中，直到被他的**父进程回收**。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。
- 一个终止了却还未被回收的进程称为**僵死进程**
- 如果一个父进程终止了，内核会安排init进程称为它孤儿进程的养父。init进程是系统启动时由内核创建的，不会终止，是所有进程的祖先。
- 一个进程可以用**waitpid**函数来等待它的子进程终止或者停止
- signal(int signum, sighandler_t handler)函数修改和信号相关联的默认行为
  - 如果handler是SIG_IGN，那么忽略类型为signum的信号
  - 如果handler是SIG_DFL，那么类型为signum的信号行为恢复为默认行为
  - 否则，handler就是用户定义的函数的地址，这个函数称为**信号处理程序**

## 第九章 虚拟内存

- 虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组
- 每字节都有一个唯一的虚拟地址，作为到数组的索引
- 磁盘上数组的内容被缓存主存中
- VM系统将虚拟内存分割为虚拟页，物理内存分割为物理页，作为磁盘和主存之间的传输单元
- 虚拟页有三个不相交的子集
  - 还未分配的页，在磁盘上不存在
  - 已分配但还未缓存在物理内存中（缺页）
  - 已分配并缓存在物理内存中
- 页表（PTE数组）将虚拟页映射到物理页，将虚拟地址转换为物理地址
- PTE数组
  - 标志位为1说明该虚拟页已经缓存到物理内存中
  - 标志位为0说明分配了但是未缓存在物理内存中
- 缺页后，调用异常处理程序更新页表，处理程序返回后重新把导致缺页的虚拟地址重发到地址翻译软件，页命中