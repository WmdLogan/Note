# 深入理解计算机系统

## 第一章 计算机系统漫游

- 

```
gcc -o hello hello.c
```

- **hello.c** -> 预处理器(cpp) -> **hello.i** -> 编译器(ccl) -> **hello.s** ->汇编器(as) -> **hello.o **->链接器(ld)  -> **hello**
  - hello.i：修改了的源程序（文本）
  - hello.s：汇编语言程序（文本）
  - hello.o：可重定位的目标程序 —— 打包机器语言指令（二进制）
  - hello：可执行目标程序（二进制），可以被加载到内存中，由系统执行

- **链接阶段**：将例如 printf.o 这些预编译好的单独文件合并到我们的程序中
- 计算机硬件组成
  - 总线被设计成传送定长的字节块，也就是**字（word）**，字长4个字节是32位系统，8个字节是64位系统
  - I/O设备通过**控制器或者适配器**与I/O总线相连，控制器和适配器的区别在于它们的组装方式。
- 程序的机器指令：磁盘 -> 主存 -> 处理器
- 上下文：操作系统保持跟踪进程运行所需的所有状态信息，包括PC、寄存器文件的当前值、主存的内容，操作系统通过上         下文切换来切换进程运行，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程
- 从一个进程到另一个进程的转换就是由操作系统**内核**管理的。**内核**是操作系统代码常驻主存的部分
- 进程的虚拟内存空间（P13）地址从小到大如下：
  - 程序代码和数据。对所有进程来说，代码从同一固定位置开始，紧接着是数据位置
  - 堆。malloc和free
  - 共享库。如C标准库和数学库
  - 内核虚拟内存。程序必须通过调用内核来读写这个区的内容或者调用内核代码定义的函数
- 线程级并发，指令级并行
- 操作系统内核时应用程序和硬件之间的媒介，提供了三个基本的抽象
  - 文件是对I/O设备的抽象
  - 虚拟内存是对主存和磁盘的抽象
  - 进程是对处理器、主存和I/O设备的抽象

## 第二章 信息的表示和处理

- 大多数计算机使用**字节**，作为最小的可寻址的内存单位。机器级程序将内存视为一个非常大的**字节数组**，成为**虚拟内存**
- 字长决定虚拟地址空间的最大大小，32位限制虚拟地址空间为4GB（刚超过4*10^9个字节）, 64位为4EB
- 排列表示一个对象的字节分小端法和大端法。通过网络传送二进制数据时必须转换成网络标准
- int float 指针等数据类型在不同机器上受字节顺序和字节大小影响，而ASCII码则不受影响。
- 几乎所有机器，C语言对有符号数使用算数右移/左移
- 强转保持位值不变，只是改变了解释这些位的方式。
  - 例如：-12345(1100111111000111)强转成无符号变为53191，原数+2^16
  - 最大无符号整数（11111111）强转成有符号变为-1
  - **有符号与无符号运算，隐式将有符号转换为无符号**容易造成程序错误

## 第三章 程序的机器级表示

- 机器级程序使用的内存地址是**虚拟地址**，提供的内存模型看上去是一个非常大的字节数组。**操作系统**负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址
- 机器代码只是简单的将内存看成一个很大的、按字节寻址的数组。
- 程序内存包含：
  - 程序的可执行机器代码
  - 操作系统需要的一些信息
  - 用来管理过程调用和返回的运行时栈
  - 用户分配的内存块
- linux中 object -d xxxx.o 反汇编机器代码
- 可以将字节唯一地解码成机器指令
- 一个x86-64的CPU包含一组16个存储64位值的**通用目的寄存器**，这些寄存器用来存储整数数据和指针
- 程序调用函数，将返回地址压入栈
- 数据传送（函数参数）通过寄存器实现，寄存器的使用取决于要传递的数据类型的大小。这样不同过程可以通过访问寄存器来访问参数。
- 如果一个函数有超过6个整形参数，超出6个的部分就要通过栈来传递
- 寄存器分为“被调用者保存寄存器”和“调用者保存寄存器”.当过程P调用过程Q时，不能改变前者，后者可以改变。
- struct 和 union 的区别
- 编译器会对struct进行数据对齐，确保字节数是4的倍数
- 将指针从一种类型强制转换成另一种类型，只改变它的类型，不改变它的值

## 第四章 处理器体系结构

- 处理一条指令：取指 -> 译码 -> 执行 -> 访存 -> 写回 -> 更新PC，处理器无限循环执行这些阶段
- 流水线执行

### 第五章 优化程序性能

- gcc编译器选项 -og、-o1、-o2、-o3调用gcc对程序优化
- 两个指针可能指向同一个内存位置的情况称为**内存别名使用**。如果编译器不能确定两个指针是否指向同一位置，就必须假设什么情况都有可能，这就限制了可能的优化策略
- 

